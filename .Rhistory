# Set the working directory (location where lab_4_incomplete.R and associated data are available)
# Pay attention to forward slash /
setwd('C:/Users/14037/OneDrive - University of Calgary/Documents/ENCI_570/TM_PHES_code')
## install the required packages. This needs to be done the first time you run the script
## weathercan is the package that retrieves the data from the Meteorological Service of Canada
## database https://climate.weather.gc.ca/historical_data/search_historic_data_e.html
install.packages("weathercan", repos = c("https://ropensci.r-universe.dev", "https://cloud.r-project.org"))
## sf package works with vector data
# install.packages('sf')
## leaflet package produces interactive spatial maps
# install.packages('leaflet')
## reshape2 is a package used to preprocess data frames
# install.packages('reshape2')
## ggplot2 makes nice figures
# install.packages('ggplot2')
## load the required packages
library('weathercan')
library('sf')
library('leaflet')
library('reshape2')
library('ggplot2')
# Set the working directory (location where lab_4_incomplete.R and associated data are available)
# Pay attention to forward slash /
setwd('C:/Users/14037/OneDrive - University of Calgary/Documents/ENCI_570/TM_PHES_code/TM_PHES')
# Read the shapefile of the watershed boundary using st_read()
basin <- st_read('shapefile.shp')
# Select the actual boundary (correct feature) as the rest are errors generated by the delineation algorithm
basin <- basin[2,]
# Reproject the layer to WGS 84 since weather gauges coordinates are in WGS 84.
# Use st_transform with crs=4326 as parameter. 4326 is the EPSG code of WGS 84 CRS
basin <- st_transform(basin, crs = 4326) #4326 is the EPSG code of WGS 84 CRS
# Get basin centroid coordinates to search for nearby weather stations
basin_centroid <- st_coordinates(st_centroid(basin))
# If you face an error because the geometry is not valid, you need to make it valid
# use st_make_valid()
basin <- st_make_valid(basin)
#Get basin centroid for the valid geometry
basin_centroid <- st_coordinates(st_centroid(basin))
# Search for nearby weather stations that has daily data
avail_stn <- stations_search(coords = rev(basin_centroid), # the function needs lat then lon
interval = 'day',
dist = 25) # searches by last year of record, location, and distance
print(avail_stn)
######################
# Visualize the watershed and available points
# Convert avail_stn to sf (shapefile) object to be plotted
# Use st_as_sf() with the following parameters: coords = c('lon', 'lat'), crs= 4326
avail_stn_shp <- st_as_sf(avail_stn, coords = c('lon', 'lat'), crs= 4326)
# Convert basin to a data frame for plotting
basin_df <- st_as_sf(basin, crs = 4326) %>% st_sf()
#plotting an interactive map
leaflet() %>% # this operator (%>%) is called pipe, which means then
addTiles() %>% #load background image
addCircleMarkers(data = avail_stn_shp, label = ~station_name,
labelOptions = labelOptions(noHide = TRUE, direction = 'top', textOnly = TRUE)) %>%
addPolygons(data = basin, color = 'red')
library(readxl)
install.packages("readxl")
library(readxl)
library('weathercan')
library('sf')
library('leaflet')
library('reshape2')
library('ggplot2')
# Set the working directory (location where lab_4_incomplete.R and associated data are available)
# Pay attention to forward slash /
setwd('C:/Users/14037/OneDrive - University of Calgary/Documents/ENCI_570/TM_PHES_code/TM_PHES')
# Read the shapefile of the watershed boundary using st_read()
basin <- st_read('shapefile.shp')
# Select the actual boundary (correct feature) as the rest are errors generated by the delineation algorithm
basin <- basin[2,]
# Reproject the layer to WGS 84 since weather gauges coordinates are in WGS 84.
# Use st_transform with crs=4326 as parameter. 4326 is the EPSG code of WGS 84 CRS
basin <- st_transform(basin, crs = 4326) #4326 is the EPSG code of WGS 84 CRS
# Get basin centroid coordinates to search for nearby weather stations
basin_centroid <- st_coordinates(st_centroid(basin))
# If you face an error because the geometry is not valid, you need to make it valid
# use st_make_valid()
basin <- st_make_valid(basin)
#Get basin centroid for the valid geometry
basin_centroid <- st_coordinates(st_centroid(basin))
# Specify the path to your Excel file
excel_file_path <- "C:/Users/14037/OneDrive - University of Calgary/Documents/ENCI_570/TM_PHES_code/gauge_location_year.xlsx"
# Read the Excel file into a data frame
excel_data <- read_excel(excel_file_path)
# View the contents of the data frame
print(excel_data)
# Read the Excel file into a data frame
excel_data <- read_excel(excel_file_path)
# Read the Excel file into a data frame
excel_data <- read_excel(excel_file_path)
# View the contents of the data frame
print(excel_data)
# Function to convert DMS to decimal degrees
dms_to_dd <- function(dms) {
parts <- strsplit(dms, "[°'\" ]")
degrees <- as.numeric(parts[[1]][1])
minutes <- as.numeric(parts[[1]][2])
seconds <- as.numeric(parts[[1]][3])
dd <- degrees + minutes/60 + seconds/3600
if (grepl("[SW]", dms)) {
dd <- -dd
}
return(dd)
}
# Apply the function to convert DMS to decimal degrees
excel_data$lat_dd <- dms_to_dd(df$lat)
# Apply the function to convert DMS to decimal degrees
excel_data$lat_dd <- dms_to_dd(excel_data$lat)
# Function to convert DMS to decimal degrees
dms_to_dd <- function(dms) {
degrees <- as.numeric(substring(dms, 1, 2))
minutes <- as.numeric(substring(dms, 4, 5))
seconds <- as.numeric(substring(dms, 7, 8))
dd <- degrees + minutes/60 + seconds/3600
dd[grepl("[SW]", dms)] <- -dd[grepl("[SW]", dms)]
return(dd)
}
# Apply the function to convert DMS to decimal degrees
excel_data$lat_dd <- dms_to_dd(excel_data$lat)
excel_data$long_dd <- dms_to_dd(excel_data$long)
print(excel_data)
excel_data$long_dd <- dms_to_dd(excel_data$lon)
print(excel_data)
# Function to convert DMS to decimal degrees
dms_to_dd <- function(dms, direction) {
parts <- strsplit(dms, "[°'\" ]")
degrees <- as.numeric(parts[[1]][1])
minutes <- as.numeric(parts[[1]][2])
seconds <- as.numeric(parts[[1]][3])
dd <- degrees + minutes/60 + seconds/3600
if (direction %in% c("S", "W")) {
dd <- -dd
}
return(dd)
}
# Apply the function to convert DMS to decimal degrees
excel_data$lat_dd <- dms_to_dd(excel_data$lat)
# Specify the path to your Excel file
excel_file_path <- "C:/Users/14037/OneDrive - University of Calgary/Documents/ENCI_570/TM_PHES_code/gauge_location_year.xlsx"
# Read the Excel file into a data frame
excel_data <- read_excel(excel_file_path)
# View the contents of the data frame
print(excel_data)
# Function to convert DMS to decimal degrees
dms_to_dd <- function(dms, direction) {
parts <- strsplit(dms, "[°'\" ]")
degrees <- as.numeric(parts[[1]][1])
minutes <- as.numeric(parts[[1]][2])
seconds <- as.numeric(parts[[1]][3])
dd <- degrees + minutes/60 + seconds/3600
if (direction %in% c("S", "W")) {
dd <- -dd
}
return(dd)
}
# Apply the function to convert DMS to decimal degrees
excel_data$lat_dd <- dms_to_dd(excel_data$lat)
# Function to convert DMS to decimal degrees
dms_to_dd <- function(dms, direction) {
parts <- strsplit(dms, "[°'\" ]")
degrees <- as.numeric(parts[[1]][1])
minutes <- as.numeric(parts[[1]][2])
seconds <- as.numeric(parts[[1]][3])
dd <- degrees + minutes/60 + seconds/3600
if (direction %in% c("S", "W")) {
dd <- -dd
}
return(dd)
}
# Apply the function to convert DMS to decimal degrees
# Convert DMS to decimal degrees for latitude
excel_data$lat_dd <- dms_to_dd(excel_data$lat, substr(excel_data$lat, nchar(excel_data$lat), nchar(excel_data$lat)))
# Function to convert DMS to decimal degrees
dms_to_dd <- function(dms) {
parts <- strsplit(dms, "[°'\" ]")
degrees <- as.numeric(parts[[1]][1])
minutes <- as.numeric(parts[[1]][2])
seconds <- as.numeric(parts[[1]][3])
direction <- substr(dms, nchar(dms), nchar(dms))
dd <- degrees + minutes/60 + seconds/3600
if (direction %in% c("S", "W")) {
dd <- -dd
}
return(dd)
}
# Convert DMS to decimal degrees for latitude
excel_data$lat_dd <- dms_to_dd(excel_data$lat)
# Function to convert DMS to decimal degrees
dms_to_dd <- function(dms) {
parts <- strsplit(dms, "[°'\" ]")
degrees <- as.numeric(parts[[1]][1])
minutes <- as.numeric(parts[[1]][2])
seconds <- as.numeric(parts[[1]][3])
direction <- substr(dms, nchar(dms), nchar(dms))
dd <- degrees + minutes/60 + seconds/3600
if (any(direction %in% c("S", "W"))) {
dd <- -dd
}
return(dd)
}
# Convert DMS to decimal degrees for latitude
excel_data$lat_dd <- dms_to_dd(excel_data$lat)
# Convert DMS to decimal degrees for longitude
excel_data$lon_dd <- dms_to_dd(excel_data$lon)
print(excel_data)
######################
# Visualize the watershed and available points
# Convert avail_stn to sf (shapefile) object to be plotted
# Use st_as_sf() with the following parameters: coords = c('lon', 'lat'), crs= 4326
avail_stn_shp <- st_as_sf(excel_data, coords = c('lon_dd', 'lat_dd'), crs= 4326)
# Convert basin to a data frame for plotting
basin_df <- st_as_sf(basin, crs = 4326) %>% st_sf()
#plotting an interactive map
leaflet() %>% # this operator (%>%) is called pipe, which means then
addTiles() %>% #load background image
addCircleMarkers(data = avail_stn_shp, label = ~gstation_name,
labelOptions = labelOptions(noHide = TRUE, direction = 'top', textOnly = TRUE)) %>%
addPolygons(data = basin, color = 'red')
# Specify the path to your Excel file
excel_file_path <- "C:/Users/14037/OneDrive - University of Calgary/Documents/ENCI_570/TM_PHES_code/gauge_location_year.xlsx"
# Read the Excel file into a data frame
excel_data <- read_excel(excel_file_path)
# View the contents of the data frame
print(excel_data)
# Function to convert DMS to decimal degrees
dms_to_dd <- function(dms) {
parts <- strsplit(dms, "[°'\" ]")
degrees <- as.numeric(parts[[1]][1])
minutes <- as.numeric(parts[[1]][2])
seconds <- as.numeric(parts[[1]][3])
direction <- substr(dms, nchar(dms), nchar(dms))
dd <- degrees + minutes/60 + seconds/3600
if (direction %in% c("S", "W")) {
dd <- -abs(dd)
}
return(dd)
}
# Convert DMS to decimal degrees for latitude
excel_data$lat_dd <- dms_to_dd(excel_data$lat)
# Function to convert DMS to decimal degrees
dms_to_dd <- function(dms) {
degrees <- as.numeric(substring(dms, 1, regexpr("[°]", dms) - 1))
minutes <- as.numeric(substring(dms, regexpr("[°]", dms) + 1, regexpr("'", dms) - 1))
seconds <- as.numeric(substring(dms, regexpr("'", dms) + 1, regexpr("\"", dms) - 1))
direction <- substring(dms, nchar(dms), nchar(dms))
dd <- degrees + minutes/60 + seconds/3600
dd[direction %in% c("S", "W")] <- -abs(dd[direction %in% c("S", "W")])
return(dd)
}
# Convert DMS to decimal degrees for latitude
excel_data$lat_dd <- dms_to_dd(excel_data$lat)
# Convert DMS to decimal degrees for longitude
excel_data$lon_dd <- dms_to_dd(excel_data$lon)
print(excel_data)
######################
# Visualize the watershed and available points
# Convert avail_stn to sf (shapefile) object to be plotted
# Use st_as_sf() with the following parameters: coords = c('lon', 'lat'), crs= 4326
avail_stn_shp <- st_as_sf(excel_data, coords = c('lon_dd', 'lat_dd'), crs= 4326)
# Convert basin to a data frame for plotting
basin_df <- st_as_sf(basin, crs = 4326) %>% st_sf()
#plotting an interactive map
leaflet() %>% # this operator (%>%) is called pipe, which means then
addTiles() %>% #load background image
addCircleMarkers(data = avail_stn_shp, label = ~gstation_name,
labelOptions = labelOptions(noHide = TRUE, direction = 'top', textOnly = TRUE)) %>%
addPolygons(data = basin, color = 'red')
# Save weather_data as a CSV file
write.csv(excel_data, "gauge_data.csv", row.names = FALSE)
# Specify the path to your Excel file
excel_file_path <- "C:/Users/14037/OneDrive - University of Calgary/Documents/ENCI_570/TM_PHES_code/gauge_location_raw.xlsx"
# Read the Excel file into a data frame
excel_data <- read_excel(excel_file_path)
# View the contents of the data frame
print(excel_data)
# Function to convert DMS to decimal degrees
dms_to_dd <- function(dms) {
degrees <- as.numeric(substring(dms, 1, regexpr("[°]", dms) - 1))
minutes <- as.numeric(substring(dms, regexpr("[°]", dms) + 1, regexpr("'", dms) - 1))
seconds <- as.numeric(substring(dms, regexpr("'", dms) + 1, regexpr("\"", dms) - 1))
direction <- substring(dms, nchar(dms), nchar(dms))
dd <- degrees + minutes/60 + seconds/3600
dd[direction %in% c("S", "W")] <- -abs(dd[direction %in% c("S", "W")])
return(dd)
}
# Convert DMS to decimal degrees for latitude
excel_data$lat_dd <- dms_to_dd(excel_data$lat)
# Convert DMS to decimal degrees for longitude
excel_data$lon_dd <- dms_to_dd(excel_data$lon)
print(excel_data)
######################
# Visualize the watershed and available points
# Convert avail_stn to sf (shapefile) object to be plotted
# Use st_as_sf() with the following parameters: coords = c('lon', 'lat'), crs= 4326
avail_stn_shp <- st_as_sf(excel_data, coords = c('lon_dd', 'lat_dd'), crs= 4326)
# Convert basin to a data frame for plotting
basin_df <- st_as_sf(basin, crs = 4326) %>% st_sf()
#plotting an interactive map
leaflet() %>% # this operator (%>%) is called pipe, which means then
addTiles() %>% #load background image
addCircleMarkers(data = avail_stn_shp, label = ~gstation_name,
labelOptions = labelOptions(noHide = TRUE, direction = 'top', textOnly = TRUE)) %>%
addPolygons(data = basin, color = 'red')
# Save weather_data as a CSV file
write.csv(excel_data, "gauge_data.csv", row.names = FALSE)
